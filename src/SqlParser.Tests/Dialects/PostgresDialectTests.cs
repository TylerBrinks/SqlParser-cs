using SqlParser.Ast;
using SqlParser.Dialects;

using static SqlParser.Ast.Expression;
using DataType = SqlParser.Ast.DataType;
using ObjectType = SqlParser.Ast.ObjectType;
using Subscript = SqlParser.Ast.Subscript;

// ReSharper disable StringLiteralTypo

namespace SqlParser.Tests.Dialects;

public class PostgresDialectTests : ParserTestBase
{
    public PostgresDialectTests()
    {
        DefaultDialects = new[] { new PostgreSqlDialect() };
    }

    [Fact]
    public void Parse_Create_Table_Generated_Always_As_Identity()
    {
        //With primary key
        var sql = """
                CREATE TABLE table2 (
                column21 bigint primary key generated always as identity,
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column21 BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column21 bigint primary key generated by default as identity,
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column21 BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                 column30 TEXT)
                """);

        //Without primary key
        sql = """
                CREATE TABLE table2 (
                column22 bigint generated always as identity    ,
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column22 BIGINT GENERATED ALWAYS AS IDENTITY,
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column22 bigint generated by default as identity    ,
                 column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column22 BIGINT GENERATED BY DEFAULT AS IDENTITY,
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column23 bigint generated by default as identity (
                INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column23 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column24 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column24 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE),
                 column30 TEXT)
                """);

        sql = """
                CREATE TABLE table2 (
                column25 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column25 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2),
                 column30 TEXT)
                """);

        sql = """
                CREATE TABLE table2 (
                column26 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column26 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column27 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20),
                column30 text);
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column27 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column28 bigint generated by default as identity (INCREMENT 1 MINVALUE 1),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column28 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column29 bigint generated by default as identity (INCREMENT 1),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column29 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column22 bigint generated always as identity    ,
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column22 BIGINT GENERATED ALWAYS AS IDENTITY,
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column23 bigint generated always as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column23 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column24 bigint generated always as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column24 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column25 bigint generated always as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column25 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column26 bigint generated always as identity (
                INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column26 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column27 bigint generated always as identity (
                INCREMENT 1 MINVALUE 1 MAXVALUE 20),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column27 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column28 bigint generated always as identity (INCREMENT 1 MINVALUE 1 ),
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column28 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1),
                 column30 TEXT)
                """);


        sql = """
                CREATE TABLE table2 (
                column29 bigint generated always as identity (
                 INCREMENT 1 ),
                 column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                column29 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1),
                 column30 TEXT)
                """);

        sql = """
                CREATE TABLE table2 (
                priceInDollar numeric,
                princeInPound numeric GENERATED ALWAYS AS(priceInDollar* 0.22) STORED,
                column30 text );
                """;
        OneStatementParsesTo(sql,
            """
                CREATE TABLE table2 (
                priceInDollar NUMERIC,
                 princeInPound NUMERIC GENERATED ALWAYS AS (priceInDollar * 0.22) STORED,
                 column30 TEXT)
                """
        );
    }

    [Fact]
    public void Parse_Create_Sequence()
    {
        var sql = "CREATE SEQUENCE  name0";
        OneStatementParsesTo(sql, "CREATE SEQUENCE name0");


        sql = "CREATE SEQUENCE  IF NOT EXISTS  name0";
        OneStatementParsesTo(sql, "CREATE SEQUENCE IF NOT EXISTS name0");


        sql = "CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name0";
        OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name0");


        sql = "CREATE TEMPORARY SEQUENCE  name0";
        OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE name0");


        sql = """
                CREATE TEMPORARY SEQUENCE IF NOT EXISTS  name1
                AS BIGINT
                INCREMENT BY  1
                MINVALUE 1  MAXVALUE 20
                START WITH 10
                """;
        OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name1 AS BIGINT INCREMENT BY 1 MINVALUE 1 MAXVALUE 20 START WITH 10");


        sql = """ 
                CREATE SEQUENCE IF NOT EXISTS  name2
                AS BIGINT
                INCREMENT  1
                MINVALUE 1  MAXVALUE 20
                START WITH 10 CACHE 2 NO CYCLE
                """;
        OneStatementParsesTo(sql, "CREATE SEQUENCE IF NOT EXISTS name2 AS BIGINT INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE");


        sql = """
                CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name3
                INCREMENT  1
                NO MINVALUE  MAXVALUE 20 CACHE 2 CYCLE
                """;
        OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name3 INCREMENT 1 NO MINVALUE MAXVALUE 20 CACHE 2 CYCLE");


        sql = """
                CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name3
                INCREMENT  1
                NO MINVALUE  MAXVALUE 20 OWNED BY public.table01
                """;
        OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name3 INCREMENT 1 NO MINVALUE MAXVALUE 20 OWNED BY public.table01");


        sql = """
            CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name3
            INCREMENT  1
            NO MINVALUE  MAXVALUE 20 OWNED BY NONE
            """;
        OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name3 INCREMENT 1 NO MINVALUE MAXVALUE 20 OWNED BY NONE");

        Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE SEQUENCE foo INCREMENT 1 NO MINVALUE NO"));
    }

    [Fact]
    public void Parse_Drop_Sequence()
    {
        var sql = "DROP SEQUENCE IF EXISTS  name0 CASCADE";
        OneStatementParsesTo(sql, "DROP SEQUENCE IF EXISTS name0 CASCADE");


        sql = "DROP SEQUENCE IF EXISTS  name1 RESTRICT";
        OneStatementParsesTo(sql, "DROP SEQUENCE IF EXISTS name1 RESTRICT");


        sql = "DROP SEQUENCE  name2 CASCADE";
        OneStatementParsesTo(sql, "DROP SEQUENCE name2 CASCADE");


        sql = "DROP SEQUENCE  name2";
        OneStatementParsesTo(sql, "DROP SEQUENCE name2");


        sql = "DROP SEQUENCE  name0 CASCADE";
        OneStatementParsesTo(sql, "DROP SEQUENCE name0 CASCADE");


        sql = "DROP SEQUENCE  name1 RESTRICT";
        OneStatementParsesTo(sql, "DROP SEQUENCE name1 RESTRICT");


        sql = "DROP SEQUENCE  name1, name2, name3";
        OneStatementParsesTo(sql, "DROP SEQUENCE name1, name2, name3");
    }

    [Fact]
    public void Parse_Create_Table_With_Defaults()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var sql = """
                CREATE TABLE public.customer ( 
                customer_id integer DEFAULT nextval(public.customer_customer_id_seq), 
                store_id smallint NOT NULL, 
                first_name character varying(45) NOT NULL, 
                last_name character varying(45) COLLATE "es_ES" NOT NULL, 
                email character varying(50), 
                address_id smallint NOT NULL, 
                activebool boolean DEFAULT true NOT NULL, 
                create_date date DEFAULT now()::text NOT NULL, 
                last_update timestamp without time zone DEFAULT now() NOT NULL, 
                active int NOT NULL 
                ) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
                """;

        var create = OneStatementParsesTo<Statement.CreateTable>(sql, "");

        var expected = new ColumnDef[]
        {
                new("customer_id", new DataType.Integer(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.Default(VerifiedExpr("nextval(public.customer_customer_id_seq)")))
                }),

                new("store_id", new DataType.SmallInt(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.NotNull())
                }),

                new("first_name", new DataType.CharacterVarying(new CharacterLength.IntegerLength(45)),
                    Options: new ColumnOptionDef[]
                    {
                        new(new ColumnOption.NotNull())
                    }),

                new("last_name", new DataType.CharacterVarying(new CharacterLength.IntegerLength(45)),
                    new ObjectName(new Ident("es_ES", Symbols.DoubleQuote)),
                    new ColumnOptionDef[]
                    {
                        new(new ColumnOption.NotNull())
                    }
                ),

                new("email", new DataType.CharacterVarying(new CharacterLength.IntegerLength(50))),

                new("address_id", new DataType.SmallInt(), Options: new ColumnOptionDef[]
                {
                   new(new ColumnOption.NotNull())
                }),

                new("activebool", new DataType.Boolean(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.Default(new LiteralValue(new Value.Boolean(true)))),
                    new(new ColumnOption.NotNull())
                }),

                new("create_date", new DataType.Date(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.Default(VerifiedExpr("now()::TEXT)"))),
                    new(new ColumnOption.NotNull())
                }),

                new("last_update", new DataType.Timestamp(TimezoneInfo.WithoutTimeZone),
                    Options: new ColumnOptionDef[]
                    {
                        new(new ColumnOption.Default(VerifiedExpr("now()"))),
                        new(new ColumnOption.NotNull())
                    }),

                new("active", new DataType.Int(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.NotNull())
                })
        };

        Assert.Equal("public.customer", create.Element.Name);
        Assert.Equal(expected, create.Element.Columns);
    }

    [Fact]
    public void Parse_Create_Table_From_Pg_Dump()
    {
        const string sql = """
                CREATE TABLE public.customer (
                customer_id integer DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
                store_id smallint NOT NULL,
                first_name character varying(45) NOT NULL,
                last_name character varying(45) NOT NULL,
                info text[],
                address_id smallint NOT NULL,
                activebool boolean DEFAULT true NOT NULL,
                create_date date DEFAULT now()::DATE NOT NULL,
                create_date1 date DEFAULT 'now'::TEXT::date NOT NULL,
                last_update timestamp without time zone DEFAULT now(),
                release_year public.year,
                active int
                )
                """;
        var canonical = """
                CREATE TABLE public.customer (
                customer_id INTEGER DEFAULT nextval('public.customer_customer_id_seq'::REGCLASS) NOT NULL,
                 store_id SMALLINT NOT NULL,
                 first_name CHARACTER VARYING(45) NOT NULL,
                 last_name CHARACTER VARYING(45) NOT NULL,
                 info TEXT[],
                 address_id SMALLINT NOT NULL,
                 activebool BOOLEAN DEFAULT true NOT NULL,
                 create_date DATE DEFAULT now()::DATE NOT NULL,
                 create_date1 DATE DEFAULT 'now'::TEXT::DATE NOT NULL,
                 last_update TIMESTAMP WITHOUT TIME ZONE DEFAULT now(),
                 release_year public.year,
                 active INT
                )
                """;
        OneStatementParsesTo(sql, canonical);
    }

    [Fact]
    public void Parse_Create_Table_With_Inherit()
    {
        const string sql = """
                CREATE TABLE bazaar.settings (
                settings_id UUID PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL, 
                user_id UUID UNIQUE, 
                value TEXT[], 
                use_metric BOOLEAN DEFAULT true
                )
                """;

        VerifiedStatement(sql);
    }

    [Fact]
    public void Parse_Create_Table_Empty()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        // Zero-column tables are weird, but supported by at least PostgreSQL.
        // <https://github.com/sqlparser-rs/sqlparser-rs/pull/94>
        VerifiedStatement("CREATE TABLE t ()");
    }

    [Fact]
    public void Parse_Create_Table_Constraints_Only()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var create = VerifiedStatement<Statement.CreateTable>("CREATE TABLE t (CONSTRAINT positive CHECK (2 > 1))");

        var expected = new TableConstraint.Check(new BinaryOp(
            new LiteralValue(Number("2")),
           BinaryOperator.Gt,
            new LiteralValue(Number("1"))
        ), "positive");
        Assert.Equal("t", create.Element.Name);
        Assert.Equal(expected, create.Element.Constraints!.Single());
    }

    [Fact]
    public void Parse_Alter_Table_Constraints_Rename()
    {
        var alter = VerifiedStatement<Statement.AlterTable>(
            "ALTER TABLE tab RENAME CONSTRAINT old_name TO new_name");
        var op = (AlterTableOperation.RenameConstraint)alter.Operations.First();

        Assert.Equal("tab", alter.Name);
        Assert.Equal("old_name", op.OldName);
        Assert.Equal("new_name", op.NewName);
    }

    [Fact]
    public void Parse_Alter_Table_Alter_Column()
    {
        OneStatementParsesTo(
            "ALTER TABLE tab ALTER COLUMN is_active TYPE TEXT USING 'text'",
            "ALTER TABLE tab ALTER COLUMN is_active SET DATA TYPE TEXT USING 'text'");

        var alter = VerifiedStatement<Statement.AlterTable>(
            "ALTER TABLE tab ALTER COLUMN is_active SET DATA TYPE TEXT USING 'text'");
        var op = (AlterTableOperation.AlterColumn)alter.Operations.First();
        var @using = new LiteralValue(new Value.SingleQuotedString("text"));

        Assert.Equal("tab", alter.Name);
        Assert.Equal("is_active", op.ColumnName);
        Assert.Equal(new AlterColumnOperation.SetDataType(new DataType.Text(), @using), op.Operation);
    }

    [Fact]
    public void Parse_Create_Table_If_Not_Exists()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var create = VerifiedStatement<Statement.CreateTable>("CREATE TABLE IF NOT EXISTS uk_cities ()");

        Assert.Equal("uk_cities", create.Element.Name);
    }

    [Fact]
    public void Parse_Bad_If_Not_Exists()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF EXISTS uk_cities ()"));
        Assert.Equal("Expected end of statement, found EXISTS, Line: 1, Col: 17", ex.Message);

        ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF EXISTS uk_cities ()"));
        Assert.Equal("Expected end of statement, found EXISTS, Line: 1, Col: 17", ex.Message);

        ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF uk_cities ()"));
        Assert.Equal("Expected end of statement, found uk_cities, Line: 1, Col: 17", ex.Message);

        ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF NOT uk_cities ()"));
        Assert.Equal("Expected end of statement, found NOT, Line: 1, Col: 17", ex.Message);
    }

    [Fact]
    public void Parse_Create_Schema_If_Not_Exists()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var create = VerifiedStatement<Statement.CreateSchema>("CREATE SCHEMA IF NOT EXISTS schema_name");
        var name = (SchemaName.Simple)create.Name;
        Assert.Equal("schema_name", name.Name);
    }

    [Fact]
    public void Parse_Drop_Schema_If_Exists()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var drop = VerifiedStatement<Statement.Drop>("DROP SCHEMA IF EXISTS schema_name");
        Assert.Equal(ObjectType.Schema, drop.ObjectType);
    }

    [Fact]
    public void Parse_Copy_From_Stdin()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        const string sql = """
                COPY public.actor (actor_id, first_name, last_name, last_update, value) FROM stdin;
                1	PENELOPE	GUINESS	2006-02-15 09:34:33 0.11111
                2	NICK	WAHLBERG	2006-02-15 09:34:33 0.22222
                3	ED	CHASE	2006-02-15 09:34:33 0.312323
                4	JENNIFER	DAVIS	2006-02-15 09:34:33 0.3232
                5	JOHNNY	LOLLOBRIGIDA	2006-02-15 09:34:33 1.343
                6	BETTE	NICHOLSON	2006-02-15 09:34:33 5.0
                7	GRACE	MOSTEL	2006-02-15 09:34:33 6.0
                8	MATTHEW	JOHANSSON	2006-02-15 09:34:33 7.0
                9	JOE	SWANK	2006-02-15 09:34:33 8.0
                10	CHRISTIAN	GABLE	2006-02-15 09:34:33 9.1
                11	ZERO	CAGE	2006-02-15 09:34:33 10.001
                12	KARL	BERRY	2017-11-02 19:15:42.308637+08 11.001
                A Fateful Reflection of a Waitress And a Boat who must Discover a Sumo Wrestler in Ancient China
                Kwara & Kogi
                {""Deleted Scenes"",""Behind the Scenes""}
                'awe':5 'awe-inspir':4 'barbarella':1 'cat':13 'conquer':16 'dog':18 'feminist':10 'inspir':6 'monasteri':21 'must':15 'stori':7 'streetcar':2
                PHP	₱ USD $
                \N  Some other value
                \\.
                """;

        OneStatementParsesTo(sql, "");
    }

    [Fact]
    public void Test_Copy_To()
    {
        var copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv'");
        var source = new CopySource.Table(new ObjectName("users"), []);
        var expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"));
        Assert.Equal(expected, copy);


        copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv' DELIMITER ','");
        expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"))
        {
            LegacyOptions = new[]
            {
                    new CopyLegacyOption.Delimiter(Symbols.Comma)
                }
        };
        Assert.Equal(expected, copy);


        copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv' DELIMITER ',' CSV HEADER");
        expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"))
        {
            LegacyOptions = new CopyLegacyOption[]
            {
                    new CopyLegacyOption.Delimiter(Symbols.Comma),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[] {new CopyLegacyCsvOption.Header()})
            }
        };
        Assert.Equal(expected, copy);
    }

    [Fact]
    public void Parse_Copy_From()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        const string sql = """
                COPY table (a, b) FROM 'file.csv' WITH
                (
                    FORMAT CSV,
                    FREEZE,
                    FREEZE TRUE,
                    FREEZE FALSE,
                    DELIMITER ',',
                    NULL '',
                    HEADER,
                    HEADER TRUE,
                    HEADER FALSE,
                    QUOTE '"',
                    ESCAPE '\',
                    FORCE_QUOTE (a, b),
                    FORCE_NOT_NULL (a),
                    FORCE_NULL (b),
                    ENCODING 'utf8'
                )
                """;

        var copy = OneStatementParsesTo(sql, "");

        var source = new CopySource.Table(new ObjectName("table"), ["a", "b"]);

        var expected = new Statement.Copy(
            source,
            false,
            new CopyTarget.File("file.csv"))
        {
            Options = new CopyOption[]
            {
                    new CopyOption.Format("CSV"),
                    new CopyOption.Freeze(true),
                    new CopyOption.Freeze(true),
                    new CopyOption.Freeze(false),
                    new CopyOption.Delimiter(','),
                    new CopyOption.Null(""),
                    new CopyOption.Header(true),
                    new CopyOption.Header(true),
                    new CopyOption.Header(false),
                    new CopyOption.Quote('"'),
                    new CopyOption.Escape('\\'),
                    new CopyOption.ForceQuote(new Ident[] {"a", "b"}),
                    new CopyOption.ForceNotNull(new Ident[] {"a"}),
                    new CopyOption.ForceNull(new Ident[] {"b"}),
                    new CopyOption.Encoding("utf8"),
            }
        };

        Assert.Equal(expected, copy);
    }

    [Fact]
    public void Parse_Copy_To()
    {
        var copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv'");
        var source = new CopySource.Table(new ObjectName("users"), []);
        var expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"));
        Assert.Equal(expected, copy);


        copy = VerifiedStatement<Statement.Copy>("COPY country TO STDOUT (DELIMITER '|')");
        source = new CopySource.Table(new ObjectName("country"), []);
        expected = new Statement.Copy(source, true, new CopyTarget.Stdout())
        {
            Options = new[] { new CopyOption.Delimiter(Symbols.Pipe) }
        };
        Assert.Equal(expected, copy);


        copy = VerifiedStatement<Statement.Copy>("COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz'");
        expected = new Statement.Copy(source, true, new CopyTarget.Program("gzip > /usr1/proj/bray/sql/country_data.gz"));
        Assert.Equal(expected, copy);
    }

    [Fact]
    public void Parse_Copy_From_Before_v9_0()
    {
        var copy = VerifiedStatement<Statement.Copy>(
            "COPY users FROM 'data.csv' BINARY DELIMITER ',' NULL 'null' CSV HEADER QUOTE '\"' ESCAPE '\\' FORCE NOT NULL column");
        var source = new CopySource.Table(new ObjectName("users"), []);
        var expected = new Statement.Copy(source, false, new CopyTarget.File("data.csv"))
        {
            LegacyOptions = new CopyLegacyOption[]
            {
                    new CopyLegacyOption.Binary(),
                    new CopyLegacyOption.Delimiter(','),
                    new CopyLegacyOption.Null("null"),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[]
                    {
                        new CopyLegacyCsvOption.Header(),
                        new CopyLegacyCsvOption.Quote('\"'),
                        new CopyLegacyCsvOption.Escape('\\'),
                        new CopyLegacyCsvOption.ForceNotNull(new Ident[] {"column"}),
                    })
            }
        };

        Assert.Equal(expected, copy);


        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        copy = OneStatementParsesTo<Statement.Copy>("COPY users FROM 'data.csv' DELIMITER AS ',' NULL AS 'null' CSV QUOTE AS '\"' ESCAPE AS '\\'", "");

        expected = new Statement.Copy(source, false, new CopyTarget.File("data.csv"))
        {
            LegacyOptions = new CopyLegacyOption[]
            {
                    new CopyLegacyOption.Delimiter(','),
                    new CopyLegacyOption.Null("null"),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[]
                    {
                        new CopyLegacyCsvOption.Quote('\"'),
                        new CopyLegacyCsvOption.Escape('\\'),
                    }),
            }
        };

        Assert.Equal(expected, copy);
    }

    [Fact]
    public void Parse_Copy_To_Before_v9_0()
    {
        var copy = VerifiedStatement<Statement.Copy>(
            "COPY users TO 'data.csv' BINARY DELIMITER ',' NULL 'null' CSV HEADER QUOTE '\"' ESCAPE '\\' FORCE QUOTE column");
        var source = new CopySource.Table(new ObjectName("users"), []);
        var expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"))
        {
            LegacyOptions = new CopyLegacyOption[]
            {
                    new CopyLegacyOption.Binary(),
                    new CopyLegacyOption.Delimiter(','),
                    new CopyLegacyOption.Null("null"),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[]
                    {
                        new CopyLegacyCsvOption.Header(),
                        new CopyLegacyCsvOption.Quote('\"'),
                        new CopyLegacyCsvOption.Escape('\\'),
                        new CopyLegacyCsvOption.ForceQuote(new Ident[] {"column"}),
                    })
            }
        };

        Assert.Equal(expected, copy);

        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];
    }

    [Fact]
    public void Parse_Set()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var set = VerifiedStatement<Statement.SetVariable>("SET a = b");
        Assert.Equal(new OneOrManyWithParens<ObjectName>.One("a"), set.Variables);
        Assert.Equal(new[] { new Identifier("b") }, set.Value);

        set = VerifiedStatement<Statement.SetVariable>("SET a = 'b'");
        Assert.Equal(new OneOrManyWithParens<ObjectName>.One("a"), set.Variables);
        Assert.Equal(new[] { new LiteralValue(new Value.SingleQuotedString("b")) }, set.Value);

        set = VerifiedStatement<Statement.SetVariable>("SET a = 0");
        Assert.Equal(new OneOrManyWithParens<ObjectName>.One("a"), set.Variables);
        Assert.Equal(new[] { new LiteralValue(Number("0")) }, set.Value);

        set = VerifiedStatement<Statement.SetVariable>("SET a = DEFAULT");
        Assert.Equal(new OneOrManyWithParens<ObjectName>.One("a"), set.Variables);
        Assert.Equal(new[] { new Identifier("DEFAULT") }, set.Value);

        set = VerifiedStatement<Statement.SetVariable>("SET LOCAL a = b");
        Assert.Equal(new OneOrManyWithParens<ObjectName>.One("a"), set.Variables);
        Assert.True(set.Local);
        Assert.Equal(new[] { new Identifier("b") }, set.Value);

        set = VerifiedStatement<Statement.SetVariable>("SET a.b.c = b");
        Assert.Equal(new OneOrManyWithParens<ObjectName>.One(new ObjectName(["a", "b", "c"])),
            set.Variables);
        Assert.Equal(new[] { new Identifier("b") }, set.Value);

        set = OneStatementParsesTo<Statement.SetVariable>(
            "SET hive.tez.auto.reducer.parallelism=false",
            "SET hive.tez.auto.reducer.parallelism = false");

        Assert.Equal(new OneOrManyWithParens<ObjectName>.One(new ObjectName(["hive", "tez", "auto", "reducer", "parallelism"])),
            set.Variables);
        Assert.Equal(new[] { new LiteralValue(new Value.Boolean(false)) }, set.Value);

        OneStatementParsesTo("SET a TO b", "SET a = b");
        OneStatementParsesTo("SET SESSION a = b", "SET a = b");

        var ex = Assert.Throws<ParserException>(() => ParseSqlStatements("SET"));
        Assert.Equal("Expected identifier, found EOF", ex.Message);

        ex = Assert.Throws<ParserException>(() => ParseSqlStatements("SET a b"));
        Assert.Equal("Expected equal sign or TO, found b, Line: 1, Col: 7", ex.Message);

        ex = Assert.Throws<ParserException>(() => ParseSqlStatements("SET a ="));
        Assert.Equal("Expected variable value, found EOF", ex.Message);
    }

    [Fact]
    public void Parse_Set_Role()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var set = VerifiedStatement<Statement.SetRole>("SET SESSION ROLE NONE");
        Assert.Equal(ContextModifier.Session, set.ContextModifier);

        set = VerifiedStatement<Statement.SetRole>("SET LOCAL ROLE \"rolename\"");
        Assert.Equal(ContextModifier.Local, set.ContextModifier);
        Assert.Equal(new Ident("rolename", Symbols.DoubleQuote), set.Name);

        set = VerifiedStatement<Statement.SetRole>("SET ROLE 'rolename'");
        Assert.Equal(ContextModifier.None, set.ContextModifier);
        Assert.Equal(new Ident("rolename", Symbols.SingleQuote), set.Name);
    }

    [Fact]
    public void Parse_Show()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var show = VerifiedStatement<Statement.ShowVariable>("SHOW a a");
        Assert.Equal(new Statement.ShowVariable(new Ident[] { "a", "a" }), show);

        show = VerifiedStatement<Statement.ShowVariable>("SHOW ALL ALL");
        Assert.Equal(new Statement.ShowVariable(new Ident[] { "ALL", "ALL" }), show);
    }

    [Fact]
    public void Parse_Deallocate()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE a");
        Assert.Equal("a", deallocate.Name);
        Assert.False(deallocate.Prepared);

        deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE ALL");
        Assert.Equal("ALL", deallocate.Name);
        Assert.False(deallocate.Prepared);

        deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE PREPARE a");
        Assert.Equal("a", deallocate.Name);
        Assert.True(deallocate.Prepared);

        deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE PREPARE ALL");
        Assert.Equal("ALL", deallocate.Name);
        Assert.True(deallocate.Prepared);
    }

    [Fact]
    public void Parse_Execute()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var execute = VerifiedStatement<Statement.Execute>("EXECUTE a");
        Assert.Equal(new Statement.Execute("a", null, null), execute);

        execute = VerifiedStatement<Statement.Execute>("EXECUTE a(1, 't')");
        var parameters = new[]
        {
                new LiteralValue(Number("1")),
                new LiteralValue(new Value.SingleQuotedString("t"))
            };
        Assert.Equal(new Statement.Execute("a", parameters, null), execute);

        execute = VerifiedStatement<Statement.Execute>("EXECUTE a USING CAST(1337 AS SMALLINT), CAST(7331 AS SMALLINT)");
        Assert.Equal(new Statement.Execute("a", null, new Sequence<Expression>
            {
                new Cast(new LiteralValue(new Value.Number("1337")), new DataType.SmallInt(), CastKind.Cast),
                new Cast(new LiteralValue(new Value.Number("7331")), new DataType.SmallInt(), CastKind.Cast),
            }), execute);
    }

    [Fact]
    public void Parse_Prepare()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var prepare = VerifiedStatement<Statement.Prepare>("PREPARE a AS INSERT INTO customers VALUES (a1, a2, a3)");
        var insert = (Statement.Insert)prepare.Statement;
        var source = (Query)insert.InsertOperation.Source!;
        var values = (SetExpression.ValuesExpression)source.Body;
        Assert.Equal("a", prepare.Name);

        var expected = new[]
        {
                new Identifier("a1"),
                new Identifier("a2"),
                new Identifier("a3")
            };

        Assert.Equal(expected, values.Values.Rows.First());
    }

    [Fact]
    public void Parse_Pg_On_Conflict()
    {
        var insert = VerifiedStatement<Statement.Insert>("""
                INSERT INTO distributors (did, dname)
                 VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
                 ON CONFLICT(did)
                 DO UPDATE SET dname = EXCLUDED.dname
                """);

        var on = new OnInsert.Conflict(new OnConflict(new OnConflictAction.DoUpdate(new DoUpdateAction(
            new Statement.Assignment[]
            {
                    new(new AssignmentTarget.ColumnName("dname"), new CompoundIdentifier(new Ident[]
                    {
                        "EXCLUDED", "dname"
                    }))
            }
        )))
        {
            ConflictTarget = new ConflictTarget.Column(new Ident[] { "did" })
        });

        Assert.Equal(on, insert.InsertOperation.On);


        insert = VerifiedStatement<Statement.Insert>("""
                INSERT INTO distributors (did, dname, area)
                 VALUES (5, 'Gizmo Transglobal', 'Mars'), (6, 'Associated Computing, Inc', 'Venus')
                 ON CONFLICT(did, area)
                 DO UPDATE SET dname = EXCLUDED.dname, area = EXCLUDED.area
                """);

        on = new OnInsert.Conflict(new OnConflict(new OnConflictAction.DoUpdate(new DoUpdateAction(
            new Statement.Assignment[]
            {
                    new(new AssignmentTarget.ColumnName("dname"), new CompoundIdentifier(new Ident[]
                    {
                        "EXCLUDED",
                        "dname"
                    })),

                    new(new AssignmentTarget.ColumnName("area"), new CompoundIdentifier(new Ident[]
                    {
                        "EXCLUDED",
                        "area"
                    }))
            })))
        {
            ConflictTarget = new ConflictTarget.Column(new Ident[]
            {
                    "did",
                    "area"
            })
        });

        Assert.Equal(on, insert.InsertOperation.On);
    }

    [Fact]
    public void Parse_Pg_Returning()
    {
        var sql = "INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets') RETURNING did";
        var insert = VerifiedStatement<Statement.Insert>(sql);

        Assert.Equal("did", ((Identifier)((SelectItem.UnnamedExpression)insert.InsertOperation.Returning![0]).Expression).Ident);

        sql = """
                UPDATE weather SET temp_lo = temp_lo + 1, temp_hi = temp_lo + 15, prcp = DEFAULT
                 WHERE city = 'San Francisco' AND date = '2003-07-03'
                 RETURNING temp_lo AS lo, temp_hi AS hi, prcp
                """;

        var update = VerifiedStatement<Statement.Update>(sql);

        var expected = new SelectItem[]
        {
                new SelectItem.ExpressionWithAlias(new Identifier("temp_lo"), "lo"),
                new SelectItem.ExpressionWithAlias(new Identifier("temp_hi"), "hi"),
                new SelectItem.UnnamedExpression(new Identifier("prcp"))
        };

        Assert.Equal(expected, update.Returning!);

        sql = "DELETE FROM tasks WHERE status = 'DONE' RETURNING *";
        var delete = VerifiedStatement<Statement.Delete>(sql);

        expected =
        [
            new SelectItem.Wildcard(new WildcardAdditionalOptions())
        ];
        Assert.Equal(expected, delete.DeleteOperation.Returning!);
    }

    [Fact]
    public void Parse_Pg_Binary_Ops()
    {
        var ops = new (string Text, BinaryOperator Operator, IEnumerable<Dialect> Dialects)[]
        {
                // Sharp char and Caret cannot be used with Generic Dialect, it conflicts with identifiers
                ("#", BinaryOperator.PGBitwiseXor, new Dialect[] {new PostgreSqlDialect()}),
                ("^", BinaryOperator.PGExp, new Dialect[] {new PostgreSqlDialect()}),
                (">>", BinaryOperator.PGBitwiseShiftRight, new Dialect[] {new PostgreSqlDialect(), new GenericDialect()}),
                ("<<", BinaryOperator.PGBitwiseShiftLeft, new Dialect[] {new PostgreSqlDialect(), new GenericDialect()}),
                ("&&", BinaryOperator.PGOverlap, new Dialect[] {new PostgreSqlDialect()}),
                ("^@", BinaryOperator.PGStartsWith, new Dialect[] {new PostgreSqlDialect()}),
        };

        foreach (var op in ops)
        {
            var select = VerifiedOnlySelect($"SELECT a {op.Text} b", op.Dialects);
            Assert.Equal(new SelectItem.UnnamedExpression(new BinaryOp(
                new Identifier("a"),
                op.Operator,
                new Identifier("b")
            )), select.Projection[0]);
        }
    }

    [Fact]
    public void Parse_Pg_Unary_Ops()
    {
        var ops = new (string Text, UnaryOperator Operator)[]
        {
                ("~", UnaryOperator.PGBitwiseNot),
                ("|/", UnaryOperator.PGSquareRoot),
                ("||/", UnaryOperator.PGCubeRoot),
                ("!!", UnaryOperator.PGPrefixFactorial),
                ("@", UnaryOperator.PGAbs)
        };

        foreach (var op in ops)
        {
            var select = VerifiedOnlySelect($"SELECT {op.Text}a");
            Assert.Equal(new SelectItem.UnnamedExpression(new UnaryOp(new Identifier("a"), op.Operator)),
                select.Projection[0]);
        }
    }

    [Fact]
    public void Parse_Pg_Postfix_Factorial()
    {
        var select = VerifiedOnlySelect("SELECT a!");

        Assert.Equal(new SelectItem.UnnamedExpression(new UnaryOp(new Identifier("a"), UnaryOperator.PGPostfixFactorial)),
            select.Projection[0]);
    }

    [Fact]
    public void Parse_Pg_Regex_Match_Ops()
    {
        var ops = new (string Text, BinaryOperator Op)[]
        {
                new("~", BinaryOperator.PGRegexMatch),
                new("~*", BinaryOperator.PGRegexIMatch),
                new("!~", BinaryOperator.PGRegexNotMatch),
                new("!~*", BinaryOperator.PGRegexNotIMatch),
        };

        foreach (var op in ops)
        {
            var select = VerifiedOnlySelect($"SELECT 'abc' {op.Text} '^a'");
            Assert.Equal(new SelectItem.UnnamedExpression(new BinaryOp(
                new LiteralValue(new Value.SingleQuotedString("abc")),
                op.Op,
                new LiteralValue(new Value.SingleQuotedString("^a"))
            )), select.Projection[0]);
        }
    }

    [Fact]
    public void Parse_Array_Index_Expr()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var num = Enumerable.Range(0, 11).Select(i => new LiteralValue(Number(i.ToString()))).ToList();

        var sql = "SELECT foo[0] FROM foos";
        var select = VerifiedOnlySelect(sql);
        var expected = new Expression.Subscript(new Identifier("foo"),
            new Subscript.Index(num[0]));
        Assert.Equal(expected, select.Projection.Single().AsExpr());


        sql = "SELECT foo[0][0] FROM foos";
        select = VerifiedOnlySelect(sql);
        expected = new Expression.Subscript(
            new Expression.Subscript(new Identifier("foo"), new Subscript.Index(num[0])),
            new Subscript.Index(num[0])
        );
        Assert.Equal(expected, select.Projection.Single().AsExpr());


        sql = "SELECT bar[0][\"baz\"][\"fooz\"] FROM foos";
        select = VerifiedOnlySelect(sql);
        expected = new Expression.Subscript(
            new Expression.Subscript(
                new Expression.Subscript(
                    new Identifier("bar"), new Subscript.Index(num[0])),
                new Subscript.Index(
                    new Identifier(new Ident("baz", Symbols.DoubleQuote)))),
            new Subscript.Index(new Identifier(new Ident("fooz", Symbols.DoubleQuote))));

        Assert.Equal(expected, select.Projection.Single().AsExpr());


        sql = "SELECT (CAST(ARRAY[ARRAY[2, 3]] AS INT[][]))[1][2]";
        select = VerifiedOnlySelect(sql);

        var nested = new Nested(
            new Cast(
                new Expression.Array(
                    new ArrayExpression(new[]
                    {
                            new Expression.Array(new ArrayExpression(
                                    new[]
                                    {
                                        num[2],
                                        num[3]
                                    }, true
                                )
                            )
                    }, true)
                ),
                new DataType.Array(
                    new ArrayElementTypeDef.SquareBracket(
                        new DataType.Array(
                            new ArrayElementTypeDef.SquareBracket(
                                new DataType.Int())))),
                CastKind.Cast
            )
        );
        expected = new Expression.Subscript(
            new Expression.Subscript(nested, new Subscript.Index(num[1])),
            new Subscript.Index(num[2]));

        Assert.Equal(expected, select.Projection.Single().AsExpr());


        sql = "SELECT ARRAY[]";
        select = VerifiedOnlySelect(sql);
        var arr = new Expression.Array(new ArrayExpression(new Sequence<Expression>(), true));
        Assert.Equal(arr, select.Projection.Single().AsExpr());
    }

    [Fact]
    public void Parse_Array_SubQuery_Expr()
    {
        var select = VerifiedOnlySelect("SELECT ARRAY(SELECT 1 UNION SELECT 2)");
        var body = new SetExpression.SetOperation(
            new SetExpression.SelectExpression(new Select(new[]
            {
                        new SelectItem.UnnamedExpression(new LiteralValue(Number("1")))
            })),
            SetOperator.Union,
            new SetExpression.SelectExpression(new Select(new[]
            {
                        new SelectItem.UnnamedExpression(new LiteralValue(Number("2")))
            })),
            SetQuantifier.None);
        var expected = new Function("ARRAY")
        {
            Args = new FunctionArguments.Subquery(new Query(body))
        };

        Assert.Equal(expected, select.Projection.Single().AsExpr());
        //Assert.Fail("Implement");
    }


    [Fact]
    public void Test_Transaction_Statement()
    {
        var statement = VerifiedStatement<Statement.SetTransaction>("SET TRANSACTION SNAPSHOT '000003A1-1'");
        var expected = new Statement.SetTransaction(null, new Value.SingleQuotedString("000003A1-1"));
        Assert.Equal(expected, statement);

        statement = VerifiedStatement<Statement.SetTransaction>(
            "SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY, READ WRITE, ISOLATION LEVEL SERIALIZABLE");
        expected = new Statement.SetTransaction(new TransactionMode[]
        {
                new TransactionMode.AccessMode(TransactionAccessMode.ReadOnly),
                new TransactionMode.AccessMode(TransactionAccessMode.ReadWrite),
                new TransactionMode.IsolationLevel(TransactionIsolationLevel.Serializable)
        }, Session: true);
        Assert.Equal(expected, statement);
    }

    [Fact]
    public void Test_Json()
    {
        DefaultDialects = new[] { new PostgreSqlDialect() };
        var select = VerifiedOnlySelect("SELECT params ->> 'name' FROM events");
        var expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("params"),
            BinaryOperator.LongArrow,
            new LiteralValue(new Value.SingleQuotedString("name"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT params -> 'name' FROM events");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("params"),
            BinaryOperator.Arrow,
            new LiteralValue(new Value.SingleQuotedString("name"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT info -> 'items' ->> 'product' FROM orders");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new BinaryOp(
                new Identifier("info"),
                BinaryOperator.Arrow,
                new LiteralValue(new Value.SingleQuotedString("items"))),

            BinaryOperator.LongArrow,

            new LiteralValue(new Value.SingleQuotedString("product"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT obj -> 42");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("obj"),
            BinaryOperator.Arrow,
            new LiteralValue(new Value.Number("42"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT obj -> key");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("obj"),
            BinaryOperator.Arrow,
            new Identifier("key")
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT obj -> 3 * 2");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("obj"),
            BinaryOperator.Arrow,
            new BinaryOp(
                new LiteralValue(new Value.Number("3")),
                BinaryOperator.Multiply,
                new LiteralValue(new Value.Number("2"))
                )
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT info #> '{a,b,c}' FROM orders");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("info"),
            BinaryOperator.HashArrow,
            new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT info #> '{a,b,c}' FROM orders");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("info"),
            BinaryOperator.HashArrow,
            new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT info #>> '{a,b,c}' FROM orders");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("info"),
            BinaryOperator.HashLongArrow,
            new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT info #>> '{a,b,c}' FROM orders");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("info"),
            BinaryOperator.HashLongArrow,
            new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT info FROM orders WHERE info @> '{\"a\": 1}'");
        var expr = new BinaryOp(
            new Identifier("info"),
            BinaryOperator.AtArrow,
            new LiteralValue(new Value.SingleQuotedString("{\"a\": 1}"))
        );
        Assert.Equal(expr, select.Selection);


        select = VerifiedOnlySelect("SELECT info FROM orders WHERE '{\"a\": 1}' <@ info");
        expr = new BinaryOp(
            new LiteralValue(new Value.SingleQuotedString("{\"a\": 1}")),
            BinaryOperator.ArrowAt,
            new Identifier("info")
        );
        Assert.Equal(expr, select.Selection);


        select = VerifiedOnlySelect("SELECT info #- ARRAY['a', 'b'] FROM orders");
        expected = new SelectItem.UnnamedExpression(new BinaryOp(
            new Identifier("info"),
            BinaryOperator.HashMinus,
            new Expression.Array(new ArrayExpression(new[]
                {
                        new LiteralValue(new Value.SingleQuotedString("a")),
                        new LiteralValue(new Value.SingleQuotedString("b"))
                }, true)
            )
        ));
        Assert.Equal(expected, select.Projection.Single());


        select = VerifiedOnlySelect("SELECT info FROM orders WHERE info @? '$.a'");
        expr = new BinaryOp(
            new Identifier("info"),
            BinaryOperator.AtQuestion,
            new LiteralValue(new Value.SingleQuotedString("$.a"))
        );
        Assert.Equal(expr, select.Selection);


        select = VerifiedOnlySelect("SELECT info FROM orders WHERE info @@ '$.a'");
        expr = new BinaryOp(
            new Identifier("info"),
            BinaryOperator.AtAt,
            new LiteralValue(new Value.SingleQuotedString("$.a"))
        );
        Assert.Equal(expr, select.Selection);

        select = VerifiedOnlySelect("SELECT info FROM orders WHERE info ? 'b'");
        expr = new BinaryOp(
            new Identifier("info"),
            BinaryOperator.Question,
            new LiteralValue(new Value.SingleQuotedString("b"))
        );
        Assert.Equal(expr, select.Selection);


        select = VerifiedOnlySelect("SELECT info FROM orders WHERE info ?& ARRAY['b', 'c']");
        expr = new BinaryOp(
            new Identifier("info"),
            BinaryOperator.QuestionAnd,
            new Expression.Array(new ArrayExpression([
                new LiteralValue(new Value.SingleQuotedString("b")),
                    new LiteralValue(new Value.SingleQuotedString("c"))
            ], true))
        );
        Assert.Equal(expr, select.Selection);


        select = VerifiedOnlySelect("SELECT info FROM orders WHERE info ?| ARRAY['b', 'c']");
        expr = new BinaryOp(
            new Identifier("info"),
            BinaryOperator.QuestionPipe,
            new Expression.Array(new ArrayExpression([
                new LiteralValue(new Value.SingleQuotedString("b")),
                    new LiteralValue(new Value.SingleQuotedString("c"))
            ], true))
        );
        Assert.Equal(expr, select.Selection);
    }

    [Fact]
    public void Test_Composite_Value()
    {
        var select = VerifiedOnlySelect("SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9");
        var expectedProjection = new SelectItem.UnnamedExpression(new CompositeAccess(new Nested(new CompoundIdentifier(
            new Ident[]
            {
                    "on_hand",
                    "item"
            })), "name"));

        var expectedSelection = new BinaryOp(
            new CompositeAccess(new Nested(new CompoundIdentifier(new Ident[]
            {
                    "on_hand",
                    "item"
            })), "price"),
           BinaryOperator.Gt,
            new LiteralValue(Number("9"))
        );

        Assert.Equal(expectedProjection, select.Projection.Single());
        Assert.Equal(expectedSelection, select.Selection);


        select = VerifiedOnlySelect("SELECT (information_schema._pg_expandarray(ARRAY['i', 'i'])).n");
        expectedProjection = new SelectItem.UnnamedExpression(
            new CompositeAccess(new Nested(new Function(
                new ObjectName(
                [
                    "information_schema",
                        "_pg_expandarray"
                ]))
            {
                Args = new FunctionArguments.List(new FunctionArgumentList(null, [
                    new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new Expression.Array(new ArrayExpression(new[]
                        {
                            new LiteralValue(new Value.SingleQuotedString("i")),
                            new LiteralValue(new Value.SingleQuotedString("i"))
                        }, true))))
                ], null))
            }), "n")
        );

        Assert.Equal(expectedProjection, select.Projection.Single());
    }

    [Fact]
    public void Parse_Comments()
    {
        var comment = VerifiedStatement<Statement.Comment>("COMMENT ON COLUMN tab.name IS 'comment'");
        var expected = new Statement.Comment(new ObjectName(["tab", "name"]), CommentObject.Column, "comment");
        Assert.Equal(expected, comment);


        comment = VerifiedStatement<Statement.Comment>("COMMENT ON TABLE public.tab IS 'comment'");
        expected = new Statement.Comment(new ObjectName(["public", "tab"]), CommentObject.Table, "comment");
        Assert.Equal(expected, comment);


        comment = VerifiedStatement<Statement.Comment>("COMMENT IF EXISTS ON TABLE public.tab IS NULL");
        expected = new Statement.Comment(new ObjectName(["public", "tab"]), CommentObject.Table, IfExists: true);
        Assert.Equal(expected, comment);
    }

    [Fact]
    public void Parse_Quoted_Identifier()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        VerifiedStatement("""
                SELECT "quoted "" ident"
                """);
    }

    [Fact]
    public void Parse_Quoted_Identifier_2()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        VerifiedStatement("SELECT \"\"\"quoted ident\"\"\"");
    }

    [Fact]
    public void Parse_Local_And_Global()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        VerifiedStatement("CREATE LOCAL TEMPORARY TABLE table (COL INT)");
    }

    [Fact]
    public void Parse_On_Commit()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        VerifiedStatement("CREATE TEMPORARY TABLE table (COL INT) ON COMMIT PRESERVE ROWS");
        VerifiedStatement("CREATE TEMPORARY TABLE table (COL INT) ON COMMIT DELETE ROWS");
        VerifiedStatement("CREATE TEMPORARY TABLE table (COL INT) ON COMMIT DROP");
    }

    [Fact]
    public void Parse_Escaped_Literal_String()
    {
        const string sql = "SELECT E'\\u0001', E'\\U0010FFFF', E'\\xC', E'\\x25', E'\\2', E'\\45', E'\\445'";
        var select = VerifiedOnlySelectWithCanonical(sql, canonical: "");
        Assert.Equal(7, select.Projection.Count);

        Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("\u0001")), select.Projection[0].AsExpr());
        Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("\udbff")), select.Projection[1].AsExpr());
        Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("\u000c")), select.Projection[2].AsExpr());
        Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("%")), select.Projection[3].AsExpr());
        Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("\u0002")), select.Projection[4].AsExpr());
        Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("$")), select.Projection[5].AsExpr());
        Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("$")), select.Projection[6].AsExpr());
    }

    [Fact]
    public void Parse_Declare()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" CURSOR WITH HOLD FOR SELECT 1");
        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" CURSOR WITHOUT HOLD FOR SELECT 1");
        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" BINARY CURSOR FOR SELECT 1");
        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" ASENSITIVE CURSOR FOR SELECT 1");
        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" INSENSITIVE CURSOR FOR SELECT 1");
        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" SCROLL CURSOR FOR SELECT 1");
        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" NO SCROLL CURSOR FOR SELECT 1");
        VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" BINARY INSENSITIVE SCROLL CURSOR WITH HOLD FOR SELECT * FROM table_name LIMIT 2222");
    }

    [Fact]
    public void Parse_Current_Functions()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var select = VerifiedOnlySelect("SELECT CURRENT_CATALOG, CURRENT_USER, SESSION_USER, USER");
        Assert.Equal(new Function("CURRENT_CATALOG")
        {
            Args = new FunctionArguments.None()
        }, select.Projection[0].AsExpr());
        Assert.Equal(new Function("CURRENT_USER")
        {
            Args = new FunctionArguments.None()
        }, select.Projection[1].AsExpr());
        Assert.Equal(new Function("SESSION_USER")
        {
            Args = new FunctionArguments.None()
        }, select.Projection[2].AsExpr());
        Assert.Equal(new Function("USER")
        {
            Args = new FunctionArguments.None()
        }, select.Projection[3].AsExpr());
    }

    [Fact]
    public void Parse_Fetch()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        VerifiedStatement("FETCH 2048 IN \"SQL_CUR0x7fa44801bc00\"");
        VerifiedStatement("FETCH 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH NEXT IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH PRIOR IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH FIRST IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH LAST IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH ABSOLUTE 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH RELATIVE 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH FORWARD 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH FORWARD ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH BACKWARD 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        VerifiedStatement("FETCH BACKWARD ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
    }

    [Fact]
    public void Parse_Custom_Operator()
    {
        var select = VerifiedOnlySelect("SELECT * FROM events WHERE relname OPERATOR(database.pg_catalog.~) '^(table)$'");
        var expected = new BinaryOp(
            new Identifier("relname"),
            BinaryOperator.PGCustomBinaryOperator,
            new LiteralValue(new Value.SingleQuotedString("^(table)$"))
        )
        {
            PgOptions = new[]
            {
                    "database",
                    "pg_catalog",
                    "~"
                }
        };
        Assert.Equal(expected, select.Selection);


        select = VerifiedOnlySelect("SELECT * FROM events WHERE relname OPERATOR(pg_catalog.~) '^(table)$'");
        expected = new BinaryOp(
            new Identifier("relname"),
            BinaryOperator.PGCustomBinaryOperator,
            new LiteralValue(new Value.SingleQuotedString("^(table)$"))
        )
        {
            PgOptions = new[]
            {
                    "pg_catalog",
                    "~"
                }
        };
        Assert.Equal(expected, select.Selection);

        select = VerifiedOnlySelect("SELECT * FROM events WHERE relname OPERATOR(~) '^(table)$'");
        expected = new BinaryOp(
            new Identifier("relname"),
            BinaryOperator.PGCustomBinaryOperator,
            new LiteralValue(new Value.SingleQuotedString("^(table)$"))
        )
        {
            PgOptions = new[]
            {
                    "~"
                }
        };
        Assert.Equal(expected, select.Selection);
    }

    [Fact]
    public void Parse_Create_Role()
    {
        var role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE IF NOT EXISTS mysql_a, mysql_b");
        var expected = new Statement.CreateRole(new ObjectName[]
        {
                "mysql_a",
                "mysql_b"
        })
        {
            IfNotExists = true
        };
        Assert.Equal(expected, role);


        role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE abc LOGIN PASSWORD NULL");
        Assert.Equal(new ObjectName[] { "abc" }, role.Names);
        Assert.Equal(new Password.NullPassword(), role.Password);
        Assert.True(role.Login);

        //role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE abc WITH LOGIN PASSWORD NULL");
        role = (Statement.CreateRole)ParseSqlStatements("CREATE ROLE abc WITH LOGIN PASSWORD NULL").First()!;
        Assert.Equal(new ObjectName[] { "abc" }, role.Names);
        Assert.Equal(new Password.NullPassword(), role.Password);
        Assert.True(role.Login);


        role = (Statement.CreateRole)ParseSqlStatements("CREATE ROLE magician WITH SUPERUSER CREATEROLE NOCREATEDB BYPASSRLS INHERIT PASSWORD 'abcdef' LOGIN VALID UNTIL '2025-01-01' IN ROLE role1, role2 ROLE role3 ADMIN role4, role5 REPLICATION").First()!;

        Assert.Equal(new ObjectName[] { "magician" }, role.Names);
        Assert.False(role.IfNotExists);
        Assert.True(role.Login);
        Assert.True(role.Inherit);
        Assert.True(role.BypassRls);
        Assert.Equal(new Password.ValidPassword(new LiteralValue(new Value.SingleQuotedString("abcdef"))), role.Password);
        Assert.True(role.Superuser);
        Assert.False(role.CreateDb);
        Assert.True(role.CreateDbRole);
        Assert.True(role.Replication);
        Assert.Equal(new LiteralValue(new Value.SingleQuotedString("2025-01-01")), role.ValidUntil);
        Assert.Equal(new Ident[] { "role1", "role2" }, role.InRole!);
        Assert.Equal(new Ident[] { "role3" }, role.Role!);
        Assert.Equal(new Ident[] { "role4", "role5" }, role.Admin!);
        Assert.Null(role.AuthorizationOwner);
        Assert.Null(role.User);
        Assert.Null(role.InGroup);

        //role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE abc WITH USER foo, bar ROLE baz ");
        role = (Statement.CreateRole)ParseSqlStatements("CREATE ROLE abc WITH USER foo, bar ROLE baz ").First()!;
        Assert.Equal(new ObjectName[] { "abc" }, role.Names);
        Assert.Equal(new Ident[] { "foo", "bar" }, role.User!);
        Assert.Equal(new Ident[] { "baz" }, role.Role!);

        foreach (var keyword in new[]
                 {
                         "BYPASSRLS",
                         "CREATEDB",
                         "CREATEROLE",
                         "INHERIT",
                         "LOGIN",
                         "REPLICATION",
                         "SUPERUSER"
                     })
        {
            var sql = $"CREATE ROLE abc {keyword} NO{keyword}";
            var ex = Assert.Throws<ParserException>(() => ParseSqlStatements(sql));
            Assert.Equal($"Found multiple {keyword} or NO{keyword}", ex.Message);
        }
    }

    [Fact]
    public void Parse_Delimited_Identifiers()
    {
        var select = VerifiedOnlySelect("SELECT \"alias\".\"bar baz\", \"myfun\"(), \"simple id\" AS \"column alias\" FROM \"a table\" AS \"alias\"");

        var table = new TableFactor.Table(new ObjectName(new Ident("a table", Symbols.DoubleQuote)))
        {
            Alias = new TableAlias(new Ident("alias", Symbols.DoubleQuote))
        };

        Assert.Equal(table, select.From!.Single().Relation);
        Assert.Equal(3, select.Projection.Count);
        Assert.Equal(new CompoundIdentifier(new Ident[]
        {
                new ("alias", Symbols.DoubleQuote),
                new ("bar baz", Symbols.DoubleQuote)
        }), select.Projection[0].AsExpr());
        Assert.Equal(new Function(new ObjectName(new Ident("myfun", Symbols.DoubleQuote)))
        {
            Args = new FunctionArguments.List(FunctionArgumentList.Empty())
        }, select.Projection[1].AsExpr());

        Assert.Equal(new SelectItem.ExpressionWithAlias(new Identifier(
            new Ident("simple id", Symbols.DoubleQuote)),
            new Ident("column alias", Symbols.DoubleQuote)),
            select.Projection[2]);

        VerifiedStatement("CREATE TABLE \"foo\" (\"bar\" \"int\")");
        VerifiedStatement("ALTER TABLE foo ADD CONSTRAINT \"bar\" PRIMARY KEY (baz)");
    }

    [Fact]
    public void Parse_Create_Function()
    {
        var create = VerifiedStatement<Statement.CreateFunction>("CREATE FUNCTION add(INTEGER, INTEGER) RETURNS INTEGER LANGUAGE SQL IMMUTABLE STRICT PARALLEL SAFE AS 'select $1 + $2;'");
        var expected = new Statement.CreateFunction("add")
        {
            Args = new OperateFunctionArg[]
            {
                    new (ArgMode.None) { DataType = new DataType.Integer() },
                    new (ArgMode.None) { DataType = new DataType.Integer() }
            },
            ReturnType = new DataType.Integer(),
            Language = "SQL",
            Parallel = FunctionParallel.Safe,
            Behavior = FunctionBehavior.Immutable,
            CalledOnNull = FunctionCalledOnNull.Strict,
            FunctionBody = new CreateFunctionBody.AsBeforeOptions(new LiteralValue(new Value.SingleQuotedString("select $1 + $2;"))),
        };
        Assert.Equal(expected, create);
    }

    [Fact]
    public void Parse_Incorrect_Create_Function_Parallel()
    {
        Assert.Throws<ParserException>(() => VerifiedStatement<Statement.CreateFunction>("CREATE FUNCTION add(INTEGER, INTEGER) RETURNS INTEGER LANGUAGE SQL PARALLEL BLAH AS 'select $1 + $2;'"));
    }

    [Fact]
    public void Parse_Drop_Function()
    {
        var drop = VerifiedStatement<Statement.DropFunction>("DROP FUNCTION IF EXISTS test_func");
        var expected = new Statement.DropFunction(true, new Statement.DropFunctionDesc[]
            {
                    new("test_func")
            },
            ReferentialAction.None);
        Assert.Equal(expected, drop);


        drop = VerifiedStatement<Statement.DropFunction>("DROP FUNCTION IF EXISTS test_func(a INTEGER, IN b INTEGER = 1)");
        expected = new Statement.DropFunction(true, new Statement.DropFunctionDesc[]
            {
                    new("test_func")
                    {
                        Args = new OperateFunctionArg[]
                        {
                            new(ArgMode.None){ Name = "a", DataType = new DataType.Integer()},
                            new(ArgMode.In)
                            {
                                Name = "b", DataType = new DataType.Integer(),
                                DefaultExpr = new LiteralValue(Number("1"))
                            }
                        }
                    }
            },
            ReferentialAction.None);
        Assert.Equal(expected, drop);


        drop = VerifiedStatement<Statement.DropFunction>("DROP FUNCTION IF EXISTS test_func1(a INTEGER, IN b INTEGER = 1), test_func2(a VARCHAR, IN b INTEGER = 1)");
        expected = new Statement.DropFunction(true, new Statement.DropFunctionDesc[]
            {
                    new("test_func1")
                    {
                        Args = new OperateFunctionArg[]
                        {
                            new(ArgMode.None){ Name = "a", DataType = new DataType.Integer()},
                            new(ArgMode.In)
                            {
                                Name = "b",
                                DataType = new DataType.Integer(),
                                DefaultExpr = new LiteralValue(Number("1"))
                            }
                        }
                    },
                    new("test_func2")
                    {
                        Args = new OperateFunctionArg[]
                        {
                            new(ArgMode.None){ Name = "a", DataType = new DataType.Varchar()},
                            new(ArgMode.In)
                            {
                                Name = "b",
                                DataType = new DataType.Integer(),
                                DefaultExpr = new LiteralValue(Number("1"))
                            }
                        }
                    }
            },
            ReferentialAction.None);
        Assert.Equal(expected, drop);
    }

    [Fact]
    public void Parse_Dollar_Quoted_String()
    {
        var statements = ParseSqlStatements("SELECT $$hello$$, $tag_name$world$tag_name$, $$Foo$Bar$$, $$Foo$Bar$$col_name, $$$$, $tag_name$$tag_name$");

        var query = (Statement.Select)statements[0]!;
        var select = (SetExpression.SelectExpression)query.Query.Body;
        var projection = select.Select.Projection;

        Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("hello"))), projection[0].AsExpr());
        Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("world", "tag_name"))), projection[1].AsExpr());
        Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("Foo$Bar"))), projection[2].AsExpr());
        var expr = new SelectItem.ExpressionWithAlias(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("Foo$Bar"))), "col_name");
        Assert.Equal(expr, projection[3]);
        Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue(""))), projection[4].AsExpr());
        Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("", "tag_name"))), projection[5].AsExpr());
    }

    [Fact]
    public void Parse_Incorrect_Dollar_Quoted_String()
    {
        Assert.Throws<TokenizeException>(() => ParseSqlStatements("SELECT $x$hello$$"));
        Assert.Throws<TokenizeException>(() => ParseSqlStatements("SELECT $hello$$"));
        Assert.Throws<TokenizeException>(() => ParseSqlStatements("\"SELECT $$$"));
    }

    [Fact]
    public void Parse_Truncate()
    {
        DefaultDialects = [new PostgreSqlDialect(), new GenericDialect()];

        var truncate = VerifiedStatement("TRUNCATE db.table_name");

        var name = new ObjectName(["db", "table_name"]);
        var expected = new Statement.Truncate(name, null, false);
        Assert.Equal(expected, truncate);
    }

    [Fact]
    public void Parse_Alter_Role()
    {
        var sql = "ALTER ROLE old_name RENAME TO new_name";
        var dialect = new[] { new PostgreSqlDialect() };
        var statement = ParseSqlStatements(sql, dialect).First();
        var expected = new Statement.AlterRole("old_name", new AlterRoleOperation.RenameRole("new_name"));
        Assert.Equal(expected, statement);

        sql = "ALTER ROLE role_name WITH SUPERUSER CREATEDB CREATEROLE INHERIT LOGIN REPLICATION BYPASSRLS CONNECTION LIMIT 100 PASSWORD 'abcdef' VALID UNTIL '2025-01-01'";
        statement = VerifiedStatement(sql, dialect);
        var options = new Sequence<RoleOption>
            {
                new RoleOption.SuperUser(true),
                new RoleOption.CreateDb(true),
                new RoleOption.CreateRole(true),
                new RoleOption.Inherit(true),
                new RoleOption.Login(true),
                new RoleOption.Replication(true),
                new RoleOption.BypassRls(true),
                new RoleOption.ConnectionLimit(new LiteralValue(new Value.Number("100"))),
                new RoleOption.PasswordOption(new Password.ValidPassword(new LiteralValue(new Value.SingleQuotedString("abcdef")))),
                new RoleOption.ValidUntil(new LiteralValue(new Value.SingleQuotedString("2025-01-01")))
            };
        expected = new Statement.AlterRole("role_name", new AlterRoleOperation.WithOptions(options));
        Assert.Equal(expected, statement);

        sql = "ALTER ROLE role_name WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS PASSWORD NULL";
        statement = VerifiedStatement(sql, dialect);
        options =
        [
            new RoleOption.SuperUser(false),
                new RoleOption.CreateDb(false),
                new RoleOption.CreateRole(false),
                new RoleOption.Inherit(false),
                new RoleOption.Login(false),
                new RoleOption.Replication(false),
                new RoleOption.BypassRls(false),
                new RoleOption.PasswordOption(new Password.NullPassword())
        ];
        expected = new Statement.AlterRole("role_name", new AlterRoleOperation.WithOptions(options));
        Assert.Equal(expected, statement);


        sql = "ALTER ROLE role_name SET maintenance_work_mem FROM CURRENT";
        statement = VerifiedStatement(sql, dialect);
        expected = new Statement.AlterRole("role_name", new AlterRoleOperation.Set(
            "maintenance_work_mem", new SetConfigValue.FromCurrent(), null));
        Assert.Equal(expected, statement);


        sql = "ALTER ROLE role_name IN DATABASE database_name SET maintenance_work_mem = 100000";
        statement = ParseSqlStatements(sql, dialect).First();
        expected = new Statement.AlterRole("role_name", new AlterRoleOperation.Set(
            "maintenance_work_mem",
            new SetConfigValue.Value(new LiteralValue(new Value.Number("100000"))),
            new ObjectName(["database_name"])));
        Assert.Equal(expected, statement);


        sql = "ALTER ROLE role_name IN DATABASE database_name SET maintenance_work_mem TO 100000";
        statement = VerifiedStatement(sql, dialect);
        expected = new Statement.AlterRole("role_name", new AlterRoleOperation.Set(
            "maintenance_work_mem",
            new SetConfigValue.Value(new LiteralValue(new Value.Number("100000"))),
            new ObjectName(["database_name"])));
        Assert.Equal(expected, statement);


        sql = "ALTER ROLE role_name IN DATABASE database_name SET maintenance_work_mem TO DEFAULT";
        statement = VerifiedStatement(sql, dialect);
        expected = new Statement.AlterRole("role_name", new AlterRoleOperation.Set(
            "maintenance_work_mem",
            new SetConfigValue.Default(),
            new ObjectName(["database_name"])));
        Assert.Equal(expected, statement);


        sql = "ALTER ROLE role_name RESET ALL";
        statement = VerifiedStatement(sql, dialect);
        expected = new Statement.AlterRole("role_name", new AlterRoleOperation.Reset(new ResetConfig.All(), null));
        Assert.Equal(expected, statement);


        sql = "ALTER ROLE role_name IN DATABASE database_name RESET maintenance_work_mem";
        statement = VerifiedStatement(sql, dialect);
        expected = new Statement.AlterRole("role_name",
            new AlterRoleOperation.Reset(new ResetConfig.ConfigName("maintenance_work_mem"),
                new ObjectName(["database_name"])));
        Assert.Equal(expected, statement);

    }

    [Fact]
    public void Parse_Create_Index()
    {
        const string sql = "CREATE INDEX IF NOT EXISTS my_index ON my_table(col1,col2)";

        var createIndex = VerifiedStatement<Statement.CreateIndex>(sql, new[] { new PostgreSqlDialect() });

        Assert.Equal("my_index", createIndex.Element.Name!);
        Assert.Equal("my_table", createIndex.Element.TableName);
        Assert.Null(createIndex.Element.Using);
        Assert.False(createIndex.Element.Unique);
        Assert.True(createIndex.Element.IfNotExists);
        Assert.Equal(
        [
           new(new Identifier("col1")),
               new(new Identifier("col2"))
        ], createIndex.Element.Columns);
        Assert.Null(createIndex.Element.Include);
    }

    [Fact]
    public void Parse_Join_Constraint_Unnest_Alias()
    {
        var select = VerifiedOnlySelect("SELECT * FROM t1 JOIN UNNEST(t1.a) AS f ON c1 = c2");
        var joins = select.From!.Single().Joins;

        var expected = new Join[]
        {
                new (new TableFactor.UnNest([new CompoundIdentifier(new Ident[] { "t1", "a" })])
                    {
                        Alias = new TableAlias("f"),
                    },
                    new JoinOperator.Inner(new JoinConstraint.On(
                        new BinaryOp(
                            new Identifier("c1"),
                            BinaryOperator.Eq,
                            new Identifier("c2")
                        )))
                )
        };

        Assert.Equal(expected, joins!);
    }

    [Fact]
    public void Parse_Select_Regexp_As_Column_Name()
    {
        var dialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };
        VerifiedOnlySelect("SELECT REGEXP.REGEXP AS REGEXP FROM REGEXP AS REGEXP WHERE REGEXP.REGEXP", dialects);
    }

    [Fact]
    public void Parse_Alter_Table_Disable()
    {
        VerifiedStatement("ALTER TABLE tab DISABLE ROW LEVEL SECURITY");
        VerifiedStatement("ALTER TABLE tab DISABLE RULE rule_name");
        VerifiedStatement("ALTER TABLE tab DISABLE TRIGGER ALL");
        VerifiedStatement("ALTER TABLE tab DISABLE TRIGGER USER");
        VerifiedStatement("ALTER TABLE tab DISABLE TRIGGER trigger_name");
    }

    [Fact]
    public void Parse_Alter_Table_Enable()
    {
        VerifiedStatement("ALTER TABLE tab ENABLE ALWAYS RULE rule_name");
        VerifiedStatement("ALTER TABLE tab ENABLE ALWAYS TRIGGER trigger_name");
        VerifiedStatement("ALTER TABLE tab ENABLE REPLICA TRIGGER trigger_name");
        VerifiedStatement("ALTER TABLE tab ENABLE REPLICA RULE rule_name");
        VerifiedStatement("ALTER TABLE tab ENABLE ROW LEVEL SECURITY");
        VerifiedStatement("ALTER TABLE tab ENABLE RULE rule_name");
        VerifiedStatement("ALTER TABLE tab ENABLE TRIGGER ALL");
        VerifiedStatement("ALTER TABLE tab ENABLE TRIGGER USER");
        VerifiedStatement("ALTER TABLE tab ENABLE TRIGGER trigger_name");
    }

    [Fact]
    public void Parse_Alter_Table_Alter_Column_Add_Generated()
    {
        //VerifiedStatement("ALTER TABLE t ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY");
        //VerifiedStatement("ALTER TABLE t ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY");
        //VerifiedStatement("ALTER TABLE t ALTER COLUMN id ADD GENERATED AS IDENTITY");
        //VerifiedStatement("ALTER TABLE t ALTER COLUMN id ADD GENERATED AS IDENTITY ( INCREMENT 1 MINVALUE 1 )");
        VerifiedStatement("ALTER TABLE t ALTER COLUMN id ADD GENERATED AS IDENTITY ( )");

        Assert.Throws<ParserException>(() => ParseSqlStatements("ALTER TABLE t ALTER COLUMN id ADD GENERATED ( INCREMENT 1 MINVALUE 1 )"));
        Assert.Throws<ParserException>(() => ParseSqlStatements("ALTER TABLE t ALTER COLUMN id ADD GENERATED AS IDENTITY ( INCREMENT )"));
        Assert.Throws<ParserException>(() => ParseSqlStatements("ALTER TABLE t ALTER COLUMN id ADD GENERATED AS IDENTITY ("));
    }

    [Fact]
    public void Parse_Create_Extension()
    {
        VerifiedStatement("CREATE EXTENSION extension_name");
        VerifiedStatement("CREATE EXTENSION extension_name WITH SCHEMA schema_name");
        VerifiedStatement("CREATE EXTENSION extension_name WITH VERSION version");
        VerifiedStatement("CREATE EXTENSION extension_name WITH CASCADE");
        VerifiedStatement("CREATE EXTENSION extension_name WITH SCHEMA schema_name VERSION version CASCADE");
        VerifiedStatement("CREATE EXTENSION extension_name WITH SCHEMA schema_name CASCADE");
        VerifiedStatement("CREATE EXTENSION extension_name WITH VERSION version CASCADE");
        VerifiedStatement("CREATE EXTENSION extension_name WITH SCHEMA schema_name VERSION version");
    }

    [Fact]
    public void Test_Complex_Postgres_Insert_With_Alias()
    {
        VerifiedStatement("WITH existing AS (SELECT test_table.id FROM test_tables AS test_table WHERE (a = 12) AND (b = 34)), inserted AS (INSERT INTO test_tables AS test_table (id, a, b, c) VALUES (DEFAULT, 56, 78, 90) ON CONFLICT(a, b) DO UPDATE SET c = EXCLUDED.c WHERE (test_table.c <> EXCLUDED.c)) SELECT c FROM existing");
    }

    [Fact]
    public void Test_Simple_Postgres_Insert_With_Alias()
    {
        var insert = (Statement.Insert)VerifiedStatement("INSERT INTO test_tables AS test_table (id, a) VALUES (DEFAULT, 123)");

        var values = new Values([
            [
                    new Identifier("DEFAULT"),
                    new LiteralValue(new Value.Number("123"))
                ]
        ]);

        var columns = new Sequence<Ident> { "id", "a" };

        var expected = new Statement.Insert(new InsertOperation("test_tables",
            new Statement.Select(new Query(new SetExpression.ValuesExpression(values))))
        {
            Columns = columns,
            Into = true,
            Alias = new Ident("test_table")
        });

        Assert.Equal(expected, insert);
    }

    [Fact]
    public void Test_Simple_Postgres_Insert_With_Quoted_Alias()
    {
        var insert = (Statement.Insert)VerifiedStatement("INSERT INTO test_tables AS \"Test_Table\" (id, a) VALUES (DEFAULT, '0123')");

        var values = new Values([
            [
                    new Identifier("DEFAULT"),
                    new LiteralValue(new Value.SingleQuotedString("0123"))
                ]
        ]);

        var columns = new Sequence<Ident> { "id", "a" };

        var expected = new Statement.Insert(new InsertOperation("test_tables",
            new Statement.Select(new Query(new SetExpression.ValuesExpression(values))))
        {
            Columns = columns,
            Into = true,
            Alias = new Ident("Test_Table", Symbols.DoubleQuote)
        });

        Assert.Equal(expected, insert);
    }

    [Fact]
    public void Parse_Pg_Like_Match_Ops()
    {
        var likeMatchOps = new Dictionary<string, BinaryOperator>
            {
                { "~~", BinaryOperator.PGLikeMatch},
                { "~~*", BinaryOperator.PGILikeMatch},
                { "!~~", BinaryOperator.PGNotLikeMatch},
                { "!~~*", BinaryOperator.PGNotILikeMatch }
            };

        foreach (var op in likeMatchOps)
        {
            var select = VerifiedOnlySelect($"SELECT 'abc' {op.Key} 'a_c%'");

            Assert.Equal(new SelectItem.UnnamedExpression(new BinaryOp(
                new LiteralValue(new Value.SingleQuotedString("abc")),
                op.Value,
                new LiteralValue(new Value.SingleQuotedString("a_c%"))
            )), select.Projection[0]);
        }
    }

    [Fact]
    public void Parse_Array_Query()
    {
        VerifiedStatement("SELECT GREATEST(sections_tbl.*) AS sections FROM sections_tbl");

        VerifiedStatement("SELECT ARRAY_AGG(sections_tbl.*) AS sections FROM sections_tbl");

        VerifiedStatement("SELECT GREATEST(my_schema.sections_tbl.*) AS sections FROM sections_tbl");

        VerifiedStatement("SELECT ARRAY_AGG(my_schema.sections_tbl.*) AS sections FROM sections_tbl");
    }

    [Fact]
    public void Parse_Mat_Cte()
    {
        VerifiedStatement("WITH cte AS MATERIALIZED (SELECT id FROM accounts) SELECT id FROM cte");
        VerifiedStatement("WITH cte AS NOT MATERIALIZED (SELECT id FROM accounts) SELECT id FROM cte");
    }

    [Fact]
    public void Parse_At_Time_Zone()
    {
        VerifiedExpr("CURRENT_TIMESTAMP AT TIME ZONE tz");
        VerifiedExpr("CURRENT_TIMESTAMP AT TIME ZONE ('America/' || 'Los_Angeles')");

        var expected = new BinaryOp(
            new AtTimeZone(
                new TypedString("2001-09-28 01:00", new DataType.Timestamp(TimezoneInfo.None))
                , new Cast(new LiteralValue(new Value.SingleQuotedString("America/Los_Angeles")), new DataType.Text(), CastKind.DoubleColon)),

            BinaryOperator.Plus,
            new Interval(new LiteralValue(new Value.SingleQuotedString("23 hours")))

        );

        var tz = VerifiedExpr("TIMESTAMP '2001-09-28 01:00' AT TIME ZONE 'America/Los_Angeles'::TEXT + INTERVAL '23 hours'");
        Assert.Equal(expected, tz);
    }

    [Fact]
    public void Parse_Array_Subscript()
    {
        var expression = (Expression.Subscript)VerifiedExpr("(ARRAY[1, 2, 3, 4, 5, 6])[2]");
        Subscript expected = new Subscript.Index(new LiteralValue(new Value.Number("2")));
        Assert.Equal(expected, expression.Key);

        expression = (Expression.Subscript)VerifiedExpr("(ARRAY[1, 2, 3, 4, 5, 6])[foo]");
        expected = new Subscript.Index(new Identifier("foo"));
        Assert.Equal(expected, expression.Key);

        expression = (Expression.Subscript)VerifiedExpr("(ARRAY[1, 2, 3, 4, 5, 6])[2:5:3]");
        expected = new Subscript.Slice(
            new LiteralValue(new Value.Number("2")),
            new LiteralValue(new Value.Number("5")),
            new LiteralValue(new Value.Number("3")));
        Assert.Equal(expected, expression.Key);


        expression = (Expression.Subscript)VerifiedExpr("arr[array_length(arr) - 3:array_length(arr) - 1]");
        expected = new Subscript.Slice(
            new BinaryOp(new Function("array_length")
            {
                Args = new FunctionArguments.List(new FunctionArgumentList(null,
                        [new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new Identifier("arr")))],
                        null))
            },
                BinaryOperator.Minus,
                new LiteralValue(new Value.Number("3"))),

            new BinaryOp(new Function("array_length")
            {
                Args = new FunctionArguments.List(new FunctionArgumentList(
                        null,
                        [new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new Identifier("arr")))],
                        null))
            },
                BinaryOperator.Minus,
                new LiteralValue(new Value.Number("1"))),
            null);
        Assert.Equal(expected, expression.Key);

        expression = (Expression.Subscript)VerifiedExpr("(ARRAY[1, 2, 3, 4, 5, 6])[:5]");
        expected = new Subscript.Slice(null, new LiteralValue(new Value.Number("5")), null);
        Assert.Equal(expected, expression.Key);

        expression = (Expression.Subscript)VerifiedExpr("(ARRAY[1, 2, 3, 4, 5, 6])[2:]");
        expected = new Subscript.Slice(new LiteralValue(new Value.Number("2")), null, null);
        Assert.Equal(expected, expression.Key);

        expression = (Expression.Subscript)VerifiedExpr("(ARRAY[1, 2, 3, 4, 5, 6])[:]");
        expected = new Subscript.Slice(null, null, null);
        Assert.Equal(expected, expression.Key);

        VerifiedExpr("schedule[:2][2:]");
    }

    [Fact]
    public void Parse_Array_Multi_Subscript()
    {
        var expression = (Expression.Subscript)VerifiedExpr("make_array(1, 2, 3)[1:2][2]");
        var expected = new Expression.Subscript(
            new Expression.Subscript(
                new Function("make_array")
                {
                    Args = new FunctionArguments.List(new FunctionArgumentList(
                        null,
                        [
                            new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new LiteralValue(new Value.Number("1")))),
                                new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new LiteralValue(new Value.Number("2")))),
                                new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new LiteralValue(new Value.Number("3"))))
                        ],
                        null))
                },
                new Subscript.Slice(new LiteralValue(new Value.Number("1")), new LiteralValue(new Value.Number("2")), null)),
            new Subscript.Index(new LiteralValue(new Value.Number("2"))));

        Assert.Equal(expected, expression);
    }

    [Fact]
    public void Parse_Pg_Custom_Binary_Ops()
    {
        // Postgres supports declaring custom binary operators, using any character in the following set:
        //  + - * / < > = ~ ! @ # % ^ & | ` ?

        // Here, we test the ones used by common extensions
        List<string> operators =
        [
            // PostGIS
            "&&&", // n-D bounding boxes intersect
                "&<", // (is strictly to the left of)
                "&>", // (is strictly to the right of)
                "|=|", //  distance between A and B trajectories at their closest point of approach
                "<<#>>", // n-D distance between A and B bounding boxes
                "|>>", // A's bounding box is strictly above B's.
                "~=", // bounding box is the same
                // PGroonga
                "&@", // Full text search by a keyword
                "&@~", // Full text search by easy to use query language
                "&@*", // Similar search
                "&`", // Advanced search by ECMAScript like query language
                "&@|", // Full text search by an array of keywords
                "&@~|", //  Full text search by an array of queries in easy to use query language
                // pgtrgm
                "<<%", // second argument has a continuous extent of an ordered trigram set that matches word boundaries
                "%>>", // commutator of <<%
                "<<<->", // distance between arguments
                // hstore
                "#=", // Replace fields with matching values from hstore
                // ranges
                "-|-", // Is adjacent to
                // pg_similarity
                "~++", // L1 distance
                "~##", // Cosine Distance
                "~-~", // Dice Coefficient
                "~!!", // Euclidean Distance
                "~@~", // Hamming Distance
                "~??", // Jaccard Coefficient
                "~%%", // Jaro Distance
                "~@@", // Jaro-Winkler Distance
                "~==", // Levenshtein Distance
                "~^^", // Matching Coefficient
                "~||", // Monge-Elkan Coefficient
                "~#~", // Needleman-Wunsch Coefficient
                "~**", // Overlap Coefficient
                "~~~", // Q-Gram Distance
                "~=~", // Smith-Waterman Coefficient
                "~!~", // Smith-Waterman-Gotoh Coefficient
                "~*~", // Soundex Distance
                // soundex_operator
                ">@@<", // Soundex matches
                "<@@>", // Soundex doesn't match
            ];

        foreach (var op in operators)
        {
            TestOperator(op, BinaryOperator.Custom);
        }
    }

    [Fact]
    public void Parse_Create_Table_With_ColumnOption_Options()
    {
        const string sql = "CREATE TABLE t (c INT) WITH (foo = 'bar', a = 123)";

        var create = VerifiedStatement<Statement.CreateTable>(sql);

        Assert.Equal(new Sequence<SqlOption>
            {
                new("foo", new LiteralValue(new Value.SingleQuotedString("bar"))),
                new("a", new LiteralValue(new Value.Number("123"))),
            }, create.Element.WithOptions);
    }

    private void TestOperator(string op, BinaryOperator binaryOp)
    {
        var tokenizer = new Tokenizer();
        var dialect = new PostgreSqlDialect();
        var tokens = tokenizer.Tokenize($"a{op}b", dialect);

        Assert.Equal(3, tokens.Count);

        var expected = new BinaryOp(
            new Identifier("a"),
            binaryOp,
            new Identifier("b"));

        var canonical = $"a {op} b";

        var dialects = new List<Dialect> { dialect };
        Assert.Equal(expected, VerifiedExpr(canonical, dialects));
        Assert.Equal(expected, VerifiedExpr($"a{op}b", dialects));
    }

    [Fact]
    public void Parse_Drop_Procedure()
    {
        const string sql = "DROP PROCEDURE IF EXISTS test_proc";

        var drop = VerifiedStatement<Statement.DropProcedure>(sql);

        Assert.True(drop.IfExists);
        Assert.Equal([new(new ObjectName("test_proc"))], drop.ProcDescription);
    }

    [Fact]
    public void Parse_Alter_Table_Owner_To()
    {
        DefaultDialects = new List<Dialect> { new PostgreSqlDialect() };
        var testCases = new TestCase[]
        {
                new ("ALTER TABLE tab OWNER TO new_owner", new Owner.Identity("new_owner")),
                new ("ALTER TABLE tab OWNER TO postgres", new Owner.Identity("postgres")),
                new ("ALTER TABLE tab OWNER TO CREATE", new Owner.Identity("CREATE")),
                new ("ALTER TABLE tab OWNER TO \"new_owner\"", new Owner.Identity(new Ident("new_owner", Symbols.DoubleQuote))),
                new ("ALTER TABLE tab OWNER TO CURRENT_USER", new Owner.CurrentUser()),
                new ("ALTER TABLE tab OWNER TO CURRENT_ROLE", new Owner.CurrentRole()),
                new ("ALTER TABLE tab OWNER TO SESSION_USER", new Owner.SessionUser())
        };

        foreach (var testCase in testCases)
        {
            var alter = VerifiedStatement<Statement.AlterTable>(testCase.Sql);

            Assert.Equal("tab", alter.Name);
            Assert.Equal([new AlterTableOperation.OwnerTo(testCase.ExpectedOwner)], alter.Operations);
        }

        Assert.Throws<ParserException>(() => ParseSqlStatements("ALTER TABLE tab OWNER TO CREATE FOO"));
        Assert.Throws<ParserException>(() => ParseSqlStatements("ALTER TABLE tab OWNER TO 4"));
    }

    [Fact]
    public void Test_Table_Function_With_Ordinality()
    {
        var select = VerifiedOnlySelect("SELECT * FROM generate_series(1, 10) WITH ORDINALITY AS t");
        Assert.Single(select.From!);
        var relation = (TableFactor.Table)select.From![0].Relation!;
        Assert.True(relation.WithOrdinality);
    }

    [Fact]
    public void Test_Table_Unnest_With_Ordinality()
    {
        var select = VerifiedOnlySelect("SELECT * FROM UNNEST([10, 20, 30]) WITH ORDINALITY AS t");
        Assert.Single(select.From!);
        var relation = (TableFactor.UnNest)select.From![0].Relation!;
        Assert.True(relation.WithOrdinality);
    }

    [Fact]
    public void Create_Create_Table_With_Partition_By()
    {
        var create = VerifiedStatement<Statement.CreateTable>("CREATE TABLE t1 (a INT, b TEXT) PARTITION BY RANGE(a)").Element;
        Assert.Equal("t1", create.Name);
        Assert.Equal([new ColumnDef("a", new DataType.Int()), new ColumnDef("b", new DataType.Text())], create.Columns);

        var partition = (Function)create.PartitionBy!;

        Assert.Equal("RANGE", partition.Name);
        Assert.Equal(new FunctionArguments.List(new FunctionArgumentList(null, [
                new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new Identifier("a")))
            ], null))
            , partition.Args);
    }

    [Fact]
    public void Parse_Create_Table_On_Commit_And_As_Query()
    {
        var create = VerifiedStatement<Statement.CreateTable>("CREATE LOCAL TEMPORARY TABLE test ON COMMIT PRESERVE ROWS AS SELECT 1").Element;

        Assert.Equal("test", create.Name);
        Assert.Equal(OnCommit.PreserveRows , create.OnCommit);
        Assert.Equal(new Sequence<SelectItem.UnnamedExpression>
        {
            new (new LiteralValue(new Value.Number("1")))
        }, create.Query!.Body.AsSelect().Projection);
    }
}

public record TestCase(string Sql, Owner ExpectedOwner);
